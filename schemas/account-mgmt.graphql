# W+ Subscription API (account-mgmt.iothings.site/graphql)
# Auth: Bearer access_token | Subscription: OnWPlusSubscriptionUpdated(user_id)

"""This directive allows results to be deferred during execution"""
directive @defer on FIELD

"""Tells the service which mutation triggers this subscription."""
directive @aws_subscribe(
  """
  List of mutations which will trigger this subscription when they are called.
  """
  mutations: [String]
) on FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by a Cognito User Pools token.
"""
directive @aws_cognito_user_pools(
  """List of cognito user pool groups which have access on this field"""
  cognito_groups: [String]
) on OBJECT | FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by a Lambda Authorizer.
"""
directive @aws_lambda on OBJECT | FIELD_DEFINITION

"""
Tells the service which subscriptions will be published to when this mutation is called. This directive is deprecated use @aws_susbscribe directive instead.
"""
directive @aws_publish(
  """
  List of subscriptions which will be published to when this mutation is called.
  """
  subscriptions: [String]
) on FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by an OIDC token.
"""
directive @aws_oidc on OBJECT | FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by sigv4 signing.
"""
directive @aws_iam on OBJECT | FIELD_DEFINITION

"""Directs the schema to enforce authorization on a field"""
directive @aws_auth(
  """List of cognito user pool groups which have access on this field"""
  cognito_groups: [String]
) on FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by an API key.
"""
directive @aws_api_key on OBJECT | FIELD_DEFINITION

type Query {
  getUser(input: GetUserInput!): User
  getWPlusSubscription: WPlusSubscription!
  getWPlusSubscriptionInternal(userId: Int!): WPlusSubscription
}

type User {
  id: ID!
  firstName: String!
  lastName: String!
  email: AWSEmail!
  photo: AWSURL
  extensionAttributes: UserExtensionAttributes
}

"""
The `AWSEmail` scalar type provided by AWS AppSync, represents an Email address string that complies with [RFC 822](https://www.ietf.org/rfc/rfc822.txt). For example, "**username@example.com**" is a valid Email address.
"""
scalar AWSEmail

"""
The `AWSURL` scalar type provided by AWS AppSync, represents a valid URL string (Ex: <https://www.amazon.com/>). The URL may use any scheme and may also be a local URL (Ex: <http://localhost/>).  URLs without schemes like "**amazon.com**" or "**www.amazon.com**" are considered invalid. URLs which contain double slashes (two consecutive forward slashes) in their path are also considered invalid.
"""
scalar AWSURL

type UserExtensionAttributes {
  isSubscribed: Boolean!
}

input GetUserInput {
  id: ID!
  email: AWSEmail
}

"""  Base WPlusSubscription type"""
type WPlusSubscription {
  id: ID!
  user_id: Int!
  access_active: Boolean
  access_end_date: AWSDateTime
  eligible_to_start_trial: Boolean!
  subscription_creation_status: WPlusSubscriptionCreationStatus
  subscription_id: String
  subscription_website_id: Int
  last_magento_event_received_at: AWSDateTime
  last_magento_data_query_at: AWSDateTime
  created_at: AWSDateTime!
  updated_at: AWSDateTime!
  pending_activations: [Activation]
}

"""
The `AWSDateTime` scalar type provided by AWS AppSync, represents a valid ***extended*** [ISO 8601 DateTime](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) string. In other words, this scalar type accepts datetime strings of the form `YYYY-MM-DDThh:mm:ss.SSSZ`.  The scalar can also accept "negative years" of the form `-YYYY` which correspond to years before `0000`. For example, "**-2017-01-01T00:00Z**" and "**-9999-01-01T00:00Z**" are both valid datetime strings.  The field after the two digit seconds field is a nanoseconds field. It can accept between 1 and 9 digits. So, for example, "**1970-01-01T12:00:00.2Z**", "**1970-01-01T12:00:00.277Z**" and "**1970-01-01T12:00:00.123456789Z**" are all valid datetime strings.  The seconds and nanoseconds fields are optional (the seconds field must be specified if the nanoseconds field is to be used).  The [time zone offset](https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators) is compulsory for this scalar. The time zone offset must either be `Z` (representing the UTC time zone) or be in the format `Â±hh:mm:ss`. The seconds field in the timezone offset will be considered valid even though it is not part of the ISO 8601 standard.
"""
scalar AWSDateTime

enum WPlusSubscriptionCreationStatus {
  confirmation_pending
  success
  failed
}

type Activation {
  entity_id: Int!
  code: String!
  status: ActivationStatus!
  type: ActivationType!
  order_item_id: Int
  payment_token_id: Int
  subscription_agreement: Boolean!
  original_customer_id: Int!
  activation_customer_id: Int
  activation_date: String
  created_at: String!
  updated_at: String!
}

enum ActivationStatus {
  pending
  success
  ineligible
  invalid
}

enum ActivationType {
  trial
  monthly
  yearly
}

type Mutation {
  updateUser(input: UpdateUserInput!): User
  createUser(input: CreateUserInput!): User
  activateWPlusSubscription(input: ActivateWPlusSubscriptionInput!): WPlusSubscriptionActivation!
  publishWPlusSubscriptionUpdate(user_id: Int!, data: AWSJSON!): WPlusSubscription
}

input UpdateUserInput {
  id: ID!
  email: AWSEmail!
  firstName: String!
  lastName: String!
}

input CreateUserInput {
  email: AWSEmail!
  firstName: String!
  lastName: String!
  password: String!
  extensionAttributes: ExtensionAttributes
  termsDocumentUuid: String
}

input ExtensionAttributes {
  isSubscribed: Boolean!
}

type WPlusSubscriptionActivation {
  subscription: WPlusSubscription
  success: Boolean!
  result_code: String!
  message: String
  details: AWSJSON
  url: String
}

"""
The `AWSJSON` scalar type provided by AWS AppSync, represents a JSON string that complies with [RFC 8259](https://tools.ietf.org/html/rfc8259).  Maps like "**{\\"upvotes\\": 10}**", lists like "**[1,2,3]**", and scalar values like "**\\"AWSJSON example string\\"**", "**1**", and "**true**" are accepted as valid JSON and will automatically be parsed and loaded in the resolver mapping templates as Maps, Lists, or Scalar values rather than as the literal input strings.  Invalid JSON strings like "**{a: 1}**", "**{'a': 1}**" and "**Unquoted string**" will throw GraphQL validation errors.
"""
scalar AWSJSON

input ActivateWPlusSubscriptionInput {
  activation_code: String!
}

type Subscription {
  onWPlusSubscriptionUpdated(user_id: Int!): WPlusSubscription!
}

type Unit {
  serial: String!
}