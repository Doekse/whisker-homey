# Insight/Analytics API (insight-engine.prod.iothings.site/graphql)
# Auth: Bearer access_token

"""This directive allows results to be deferred during execution"""
directive @defer on FIELD

"""
Tells the service this field/object has access authorized by sigv4 signing.
"""
directive @aws_iam on OBJECT | FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by a Lambda Authorizer.
"""
directive @aws_lambda on OBJECT | FIELD_DEFINITION

"""
Tells the service which subscriptions will be published to when this mutation is called. This directive is deprecated use @aws_susbscribe directive instead.
"""
directive @aws_publish(
  """
  List of subscriptions which will be published to when this mutation is called.
  """
  subscriptions: [String]
) on FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by an API key.
"""
directive @aws_api_key on OBJECT | FIELD_DEFINITION

"""Tells the service which mutation triggers this subscription."""
directive @aws_subscribe(
  """
  List of mutations which will trigger this subscription when they are called.
  """
  mutations: [String]
) on FIELD_DEFINITION

"""Directs the schema to enforce authorization on a field"""
directive @aws_auth(
  """List of cognito user pool groups which have access on this field"""
  cognito_groups: [String]
) on FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by an OIDC token.
"""
directive @aws_oidc on OBJECT | FIELD_DEFINITION

"""
Tells the service this field/object has access authorized by a Cognito User Pools token.
"""
directive @aws_cognito_user_pools(
  """List of cognito user pool groups which have access on this field"""
  cognito_groups: [String]
) on OBJECT | FIELD_DEFINITION

type Query {
  getUserInsights(input: GetUserInsightsInput!, timezoneOffset: String): UserInsights!
  getInsightsSummary(timezoneOffset: String): InsightsSummary!
  getDailyRecapInsights(timezoneOffset: String): DailyRecap!
  getRobotAggregateGraph(input: GetRobotAggregateGraphInput!): GetRobotAggregateGraphOutput!
}

type UserInsights {
  isWhiskerPlus: BooleanUnknownEnum!
  story(locale: String): [Story]
  weightInsights: [ChartInsights]!
  visitInsights: [ChartInsights]!
  visitDurationInsights: [ChartInsights]!
  visitDurationEventInsights: [VisitDurationEventChartInsights]
}

enum BooleanUnknownEnum {
  TRUE
  FALSE
  UNKNOWN
}

type Story {
  petId: String!
  value: String
}

type ChartInsights {
  petId: String!
  metadata: AWSJSON
  weeklyData: ChartData
  monthlyData: MonthlyChartData
  yearlyData: ChartData
  allData: ChartData
}

"""
The `AWSJSON` scalar type provided by AWS AppSync, represents a JSON string that complies with [RFC 8259](https://tools.ietf.org/html/rfc8259).  Maps like "**{\\"upvotes\\": 10}**", lists like "**[1,2,3]**", and scalar values like "**\\"AWSJSON example string\\"**", "**1**", and "**true**" are accepted as valid JSON and will automatically be parsed and loaded in the resolver mapping templates as Maps, Lists, or Scalar values rather than as the literal input strings.  Invalid JSON strings like "**{a: 1}**", "**{'a': 1}**" and "**Unquoted string**" will throw GraphQL validation errors.
"""
scalar AWSJSON

type ChartData {
  median: Float!
  dataPoints: [GeneralDataPoint]!
}

type GeneralDataPoint {
  date: String!
  value: Float
  daily_min_value: Float
  daily_max_value: Float
  daily_avg_value: Float
  shortest_time_between_events: Float
  longest_time_between_events: Float
}

type MonthlyChartData {
  median: Float!
  dataPoints: [MonthlyDataPoint]!
}

"""  ---- INSIGHTS CHARTS ----"""
type MonthlyDataPoint {
  start: String!
  end: String!
  value: Float
}

type VisitDurationEventChartInsights {
  petId: String!
  weeklyData: ChartData
  monthlyData: ChartData
}

input GetUserInsightsInput {
  userId: String!
  isMetric: Boolean
  filter: UserInsightsFilter
}

input UserInsightsFilter {
  petIds: [String]
}

"  ---- ----\n ---- INSIGHTS SUMMARY ----"
type InsightsSummary {
  isWhiskerPlus: BooleanUnknownEnum!
  pets: [PetSummary]!
}

type PetSummary {
  petId: String!
  weightSummary: WeightSummary!
  visitSummary: VisitSummary!
}

type WeightSummary {
  medianDailyWeightLastWeek: ValueTrend
  medianWeightYesterday: ValueTrend
}

type ValueTrend {
  value: Float!
  trend: Trend
}

enum Trend {
  UP
  DOWN
  STABLE
}

type VisitSummary {
  visitCountYesterday: ValueTrend
  visitCountLastWeek: ValueTrend
  peakVisitTimeLastWeek: ValueFloat
  visitDurationYesterday: ValueTrend
}

"""  ---- ----"""
type ValueFloat {
  value: Float!
}

type DailyRecap {
  isWhiskerPlus: BooleanUnknownEnum!
  data: [DailyRecapDate]!
}

type DailyRecapDate {
  date: AWSDate!
  pets: DailyRecapPets!
}

"""
The `AWSDate` scalar type provided by AWS AppSync, represents a valid ***extended*** [ISO 8601 Date](https://en.wikipedia.org/wiki/ISO_8601#Calendar_dates) string. In other words, this scalar type accepts date strings of the form `YYYY-MM-DD`.  The scalar can also accept "negative years" of the form `-YYYY` which correspond to years before `0000`. For example, "**-2017-05-01**" and "**-9999-01-01**" are both valid dates.  This scalar type can also accept an optional [time zone offset](https://en.wikipedia.org/wiki/ISO_8601#Time_zone_designators). For example, "**1970-01-01**", "**1970-01-01Z**", "**1970-01-01-07:00**" and "**1970-01-01+05:30**" are all valid dates. The time zone offset must either be `Z` (representing the UTC time zone) or be in the format `Â±hh:mm:ss`. The seconds field in the timezone offset will be considered valid even though it is not part of the ISO 8601 standard.
"""
scalar AWSDate

type DailyRecapPets {
  isEmpty: Boolean!
  items: [DailyRecapPet]!
}

"  ---- ----\n ---- DAILY RECAP ----"
type DailyRecapPet {
  petId: String!
  medianWeight: ValueTrend
  visitCount: ValueTrend
  visitDuration: ValueTrend
  peakVisitTime: ValueTrend
  visitEvents: [GeneralDataPoint]!
}

type GetRobotAggregateGraphOutput {
  sum: Float
  dataPoints: [AggregateDataPointOuput!]
}

type AggregateDataPointOuput {
  startDate: String!
  endDate: String!
  value: Float
}

input GetRobotAggregateGraphInput {
  robotSerial: String!
  timezoneOffset: String
  measureName: RobotEventMeasureNameInput!
  aggregateFunction: AggregateFunctionTypeInput!
  aggregatePeriod: AggregatePeriodTypeInput!
  startDate: String!
  endDate: String!
}

enum RobotEventMeasureNameInput {
  LR_CYCLE
  LR_CYCLE_INTERRUPT
}

enum AggregateFunctionTypeInput {
  SUM
}

enum AggregatePeriodTypeInput {
  P1D
  P1W
  P1M
}

union Value = ValueFloat | ValueString

type ValueString {
  value: String!
}